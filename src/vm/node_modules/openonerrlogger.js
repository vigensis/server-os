/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License, Version 1.0 only
 * (the "License").  You may not use this file except in compliance
 * with the License.
 *
 * You can obtain a copy of the license at http://smartos.org/CDDL
 *
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file.
 *
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 *
 * Copyright (c) 2014, Joyent, Inc. All rights reserved.
 *
 */

var assert = require('assert');
var bunyan = require('/usr/node/node_modules/bunyan');
var fs = require('fs');

// flag whether we're writing to a process-specific log file in /var/log/vm/logs
// defaults to false, but set true when we perform an action that changes state
// or when an error occurs.
var log_to_file = false;

// keep the last 512 messages just in case we end up wanting them.
var ringbuffer = new bunyan.RingBuffer({ limit: 512 });

// OpenOnErrorFileStream is a bunyan stream that only creates the file when
// there's an error or higher level message or when the global log_to_file
// variable is set. For actions that modify things log_to_file is always set.
// For other actions we shouldn't log in the normal case but where we do want
// logs when something breaks. Thanks to Trent++ for most of this code.
//
// Note: if you want to rotate the logs while this is writing to a file, you
// can first move it. The watcher will notice that the log file was moved and
// reopen a new file with the original name.

function OpenOnErrorFileStream(filename) {
    this.path = filename;
    this.write = this.constructor.prototype.write1;
    this.end = this.constructor.prototype.end1;
    this.emit = this.constructor.prototype.emit1;
    this.once = this.constructor.prototype.once1;

    this.newStream = function (callback) {
        var mode = 438; /* =0666, default from node's fs.js */
        var self = this;

        if (self.creatingStream) {
            // Another call has already kicked off creating the stream, so
            // just return and let the ringbuffer record the log record.
            callback(null, false);
            return;
        }

        // Prevent other callers from trying to create the stream again while
        // this creation is in progress:
        self.creatingStream = true;

        fs.open(self.path, 'a', mode, function (err, fd) {
            if (err) {
                // failed to open, might have already been rotated. In any case
                // we just set the stream to null so we'll reopen next time.
                self.stream = null;
                delete self.creatingStream;
                callback(err);
                return;
            }

            self.stream = fs.createWriteStream(self.path,
                {fd: fd, encoding: 'utf8'});

            delete self.creatingStream;
            // Call the callback now that stream has been created and ready for
            // write()s.
            callback(null, true);
        });
    };
}

OpenOnErrorFileStream.prototype.end1 = function () {
    // in initial mode we're not writing anything, so nothing to flush
    return;
};

OpenOnErrorFileStream.prototype.emit1 = function () {
    return;
};

// Warning: never emits anything
OpenOnErrorFileStream.prototype.once1 = function () {
    return;
};

// used until first ERROR or higher, then opens file and ensures future writes
// go to .write2()
OpenOnErrorFileStream.prototype.write1 = function (rec) {
    var r;
    var self = this;
    var stream;

    if (rec.level >= bunyan.ERROR || log_to_file) {

        function doWrite1() {

            stream = self.stream;

            self.emit = function () { stream.emit.apply(stream, arguments); };
            self.end = function () { stream.end.apply(stream, arguments); };
            self.once = function () { stream.once.apply(stream, arguments); };
            self.write = self.constructor.prototype.write2;
            // dump out logs from ringbuffer too since there was an error so we
            // can figure out what's going on.
            for (r in ringbuffer.records) {
                r = ringbuffer.records[r];
                if (r != rec) {
                    self.write(r);
                }
            }

            self.write(rec);
        }

        if (! self.stream) {
            self.newStream(function (err, created) {
                if (err || !created) {
                    // failed to create new stream, or stream creation has
                    // started but is not yet complete - just let the
                    // ringbuffer handle for now.
                    return;
                }

                doWrite1();
            });
        } else {
            doWrite1();
        }
    }

    // This write doesn't fail (since it's going to memory or nowhere) so we
    // always return true so that callers don't try to wait for 'drain' which
    // we'll not emit.
    return true;
};

// used when writing to file
OpenOnErrorFileStream.prototype.write2 = function (rec) {
    var exists;
    var self = this;
    var str;

    // need to support writing '' so we know when to drain
    if (typeof (rec) === 'string' && rec.length < 1) {
        str = '';
    } else {
        str = JSON.stringify(rec, bunyan.safeCycles()) + '\n';
    }

    // In case the file has moved, we check that it exists before each log write
    // If it's gone, we'll close the stream and re-open so that we don't write
    // to the moved / deleted file.
    //
    // OS-3610 exists for improving this if other things its blocked on ever
    // get fixed.
    try {
        exists = fs.existsSync(self.path);
    } catch (e) {
        exists = false;
    }
    if (!exists && self.stream) {
        self.stream.destroySoon();
        self.stream = null;
    }

    if (! self.stream) {
        self.newStream(function (err, created) {
            if (err) {
                // failed to create the stream so go back to write1 which
                // will log to ringbuffer at least. Then whenever a new write
                // finally succeeds we'll flush those out to disk.
                self.write = self.constructor.prototype.write1;
                // NOTE: we don't call write() here because that could result
                // in a loop.
            } else {
                // If created is not set, stream creation has started but is
                // not yet complete - just let the ringbuffer handle for now.
                if (created) {
                    self.stream.write(str);
                }
            }
        });
    } else {
        return self.stream.write(str);
    }

    // NOTE: we need to always default to returning true so that callers don't
    // try to wait for 'drain' which we'll not emit.
    return true;
};

function createLogger(options) {
    var filename = options.filename;
    var level = options.level;
    var logname = options.logname;
    var params = {};
    var streams = [];

    assert(logname, 'createLogger(): logname is required');

    if (!level) {
        level = 'debug';
    }

    if (options.immediate) {
        log_to_file = true; // global
    }

    // Add the ringbuffer which we'll dump if we switch from not writing to
    // writing, and so that they'll show up in dumps.
    streams.push({
        level: 'trace',
        type: 'raw',
        stream: ringbuffer
    });

    if (filename) {
        streams.push({
            level: level,
            type: 'raw',
            stream: new OpenOnErrorFileStream(filename)
        });
    }

    if (options.additional_streams) {
        streams = streams.concat(options.additional_streams);
    }

    params = {
        name: logname,
        streams: streams,
        serializers: bunyan.stdSerializers
    };

    if (options.req_id) {
        params.req_id = options.req_id;
    }

    return (bunyan.createLogger(params));
}

module.exports = {
    createLogger: createLogger
};
