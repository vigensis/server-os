/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License, Version 1.0 only
 * (the "License").  You may not use this file except in compliance
 * with the License.
 *
 * You can obtain a copy of the license at http://smartos.org/CDDL
 *
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file.
 *
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 *
 * Copyright (c) 2018, Joyent, Inc.
 *
 */

/*
 * Substitute for 'zoneevent.c' that uses Vminfod or sysevents (as appropriate)
 * as an event source
 */

var EventEmitter = require('events').EventEmitter;
var util = require('util');

var assert = require('/usr/node/node_modules/assert-plus');
var VM = require('/usr/vm/node_modules/VM');

module.exports.ZoneEvent = ZoneEvent;

/*
 * ZoneEvent class
 */
function ZoneEvent(opts) {
    var self = this;

    assert(self instanceof ZoneEvent, 'must be called with "new"');

    EventEmitter.call(self);

    assert.object(opts, 'opts');
    assert.string(opts.name, 'opts.name');
    assert.object(opts.log, 'opts.log');

    self.ze_name = opts.name;
    self.ze_logger = opts.log.child({client: self.ze_name});

    self.ze_logger.info('starting ZoneEvent');

    self.start();
}
util.inherits(ZoneEvent, EventEmitter);


/*
 * Start the vmadm events stream
 */
ZoneEvent.prototype.start = function start() {
    var self = this;

    var opts = {
        log: self.ze_logger,
        name: self.ze_name
    };

    assert(!self.ze_stop, 'ZoneEvent not stopped');

    VM.events(opts, handler, ready).on('error', function (err) {
        self.emit('error', err);
    });

    function ready(err, obj) {
        if (err) {
            self.ze_logger.error({err: err}, 'ZoneEvent error');
        } else {
            assert.object(obj, 'obj');
            assert.func(obj.stop, 'obj.stop');
            self.ze_logger.debug('ZoneEvent (VM.events) ready');
            self.ze_stop = obj.stop;
        }

        self.emit('ready', err, obj);
    }

    function handler(ev) {
        self._handleVmadmEvent(ev);
    }
};

/*
 * Handle an incoming vmadm update
 */
ZoneEvent.prototype._handleVmadmEvent = function _handleVmadmEvent(ev) {
    var self = this;

    assert.object(ev, 'ev');
    assert.date(ev.date, 'ev.date');
    assert.string(ev.type, 'ev.type');
    assert.string(ev.zonename, 'ev.zonename');

    self.ze_logger.trace({ev: ev}, 'processing vmadm event');

    var zoneupdated = false;
    var obj = {
        date: ev.date,
        zonename: ev.zonename
    };

    switch (ev.type) {
    case 'create':
        obj.oldstate = '';
        obj.newstate = ev.vm.zone_state;
        zoneupdated = true;
        break;
    case 'delete':
        obj.newstate = '';
        zoneupdated = true;
        break;
    case 'modify':
        assert.array(ev.changes, 'ev.changes');
        for (var i = 0; i < ev.changes.length; i++) {
            var change = ev.changes[i];
            if (change.path.length === 1
                && change.path[0] === 'zone_state') {

                obj.oldstate = change.oldValue;
                obj.newstate = change.newValue;
                zoneupdated = true;
                break;
            }
        }
        break;
    default:
        assert(false, 'unknown vmadm event type: ' + ev.type);
        break;
    }

    if (zoneupdated) {
        /*
         * There is some discrepency with vminfod and sysevents, so we
         * translate the vminfod events to match what is expected by sysevent
         */
        if (obj.newstate === 'installed' && obj.oldstate !== 'incomplete') {
            obj.newstate = 'uninitialized';
        }
        if (obj.oldstate === 'installed') {
            obj.oldstate = 'uninitialized';
        }
        self.emit('event', obj);
    }
};

/*
 * stop the watcher
 */
ZoneEvent.prototype.stop = function vminfod_watcher_stop() {
    var self = this;

    if (self.ze_stop) {
        self.ze_stop();
        delete self.ze_stop;
    }
};

/*
 * if called directly just hook a vminfo stream to stdout
 */
if (require.main === module) {
    var zw = new ZoneEvent('Module Run Directly');
    zw.on('event', function (ev) {
        console.log(JSON.stringify(ev));
    });
}
