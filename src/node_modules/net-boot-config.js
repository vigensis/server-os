/*
 * Copyright (c) 2016, Joyent, Inc. All rights reserved.
 *
 *
 * Network boot-file functions
 */

var fmt = require('util').format;
var mod_fs = require('fs');



// --- Globals



var ARRAY_PROPS = [
    'aggregations',
    'etherstubs',
    'nictags',
    'resolvers',
    'vnics'
];
var CONFIG = process.env.NET_BOOT_CONFIG_FILE || '/system/boot/networking.json';
var HN_CONFIG = '/usbkey/boot/networking.json';
var OBJ_PROPS = [ 'nictag_rules', 'routes' ];



// --- Internal



/**
 * Fill in any missing properties from the conf object
 */
function addDefaultProperties(conf) {
    ARRAY_PROPS.forEach(function (prop) {
        if (!conf.hasOwnProperty(prop)) {
            conf[prop] = [];
        }
    });

    OBJ_PROPS.forEach(function (prop) {
        if (!conf.hasOwnProperty(prop)) {
            conf[prop] = {};
        }
    });
}



// --- Exports



/**
 * Returns true if boot-file networking is enabled
 */
function isEnabled(callback) {
    mod_fs.exists(CONFIG, function _afterEnabled(exists) {
        if (exists) {
            return callback(exists);
        }

        return mod_fs.exists(HN_CONFIG, callback);
    });
}


/**
 * Load and parse a single config file
 */
function loadConfFile(confFile, callback) {
    mod_fs.readFile(confFile, function (err, raw) {
        var conf = {};

        if (err) {
            return callback(err);
        }

        try {
            conf = JSON.parse(raw);
        } catch (err2) {
            return callback(err2);
        }

        addDefaultProperties(conf);
        return callback(null, conf);
    });
}


/**
 * Load the config file from disk
 */
function loadConfig(callback) {
    loadConfFile(CONFIG, function _afterLoad(err, conf) {
        if (err && err.code !== 'ENOENT') {
            return callback(err);
        }

        if (conf) {
            return callback(null, conf);
        }

        return loadConfFile(HN_CONFIG, function _afterHnLoad(hErr, hConf) {
            if (hErr) {
                if (hErr.code == 'ENOENT') {
                    console.warn('WARNING: No config file found');
                    hConf = {};
                    addDefaultProperties(hConf);
                    return callback(null, hConf);
                }

                return callback(hErr);
            }

            return callback(null, hConf);
        });
    });
}


function configValues(callback) {
    loadConfig(function (err, conf) {
        var ipKeys = [];
        var tagNums = {};
        var vals = {};
        var admin_tag = 'admin';

        if (err) {
            return callback(err);
        }

        if (conf.dns_domain) {
            vals.dns_domain = conf.dns_domain;
        }

        if (conf.etherstubs.length !== 0) {
            vals.etherstub = conf.etherstubs.join(',');
        }

        if (conf.hostname) {
            vals.hostname = conf.hostname;
        }

        if (conf.admin_tag) {
            admin_tag = conf.admin_tag;
        }
        vals.admin_tag = admin_tag;

        conf.nictags.forEach(function (tag) {
            if (!tag.hasOwnProperty('name')) {
                return;
            }

            /* if admin_tag is not 'admin', skip the admin nictag. */
            if (tag.name === 'admin' && admin_tag !== tag.name) {
                return;
            }

            if (tag.mac) {
                vals[tag.name + '_nic'] = tag.mac;
            }

            if (tag.mtu) {
                vals[tag.name + '_mtu'] = tag.mtu;
            }
        });

        if (conf.resolvers.length !== 0) {
            vals.dns_resolvers = conf.resolvers.join(',');
        }

        conf.vnics.forEach(function (nic) {
            var iface;
            var tag = nic.nic_tag;

            /*
             * If this is a nic tagged 'admin' and the admin_tag is not 'admin',
             * skip this.  When admin_tag is set to something other than
             * 'admin' we want to completely override the admin_nic and not
             * display it at all.
             */
            if (!tag || (tag === 'admin' && admin_tag !== tag)) {
                return;
            }

            /*
             * We name the interfaces based on what nic tag they're on, so keep
             * track of what number we're at per tag.  This results in
             * interfaces named my_tag0, my_tag1, etc.  The exceptions are the
             * "admin" and "external" config values, which are special in the
             * SDC config.  The "admin_" config keys plumb the admin physical
             * nic (not a vnic).  The "external_" config keys plumb external0.
             */
            iface = tag;
            if (!tagNums.hasOwnProperty(tag)) {
                tagNums[tag] = 0;
            }

            /*
             * If this is not the admin nic, the external nic, or the nic
             * tagged with the admin_tag, add the instance number.
             */
            if ((tag !== 'admin' && tag !== admin_tag && tag !== 'external')
                || tagNums[tag] !== 0) {
                iface = fmt('%s%d', tag, tagNums[tag]);
            }

            tagNums[tag]++;

            if (nic.ip) {
                vals[iface + '_ip'] = nic.ip;
                ipKeys.push(iface + '_ip');
            }

            if (nic.gateway) {
                vals[iface + '_gateway'] = nic.gateway;
            }

            if (nic.mac) {
                vals[iface + '_mac'] = nic.mac;
            }

            if (nic.mtu) {
                vals[iface + '_mtu'] = nic.mtu;
            }

            if (nic.netmask) {
                vals[iface + '_netmask'] = nic.netmask;
            }

            if (nic.overlay_nic_tags_provided) {
                vals[iface + '_overlay_nic_tags_provided'] =
                    nic.overlay_nic_tags_provided.join(',');
            }

            if (nic.vlan_id) {
                vals[iface + '_vlan_id'] = nic.vlan_id;
            }
        });

        if (ipKeys.length !== 0) {
            vals.bootfile_ip_keys = ipKeys.join(',');
        }

        conf.aggregations.forEach(function (aggr) {
            if (!aggr.name) {
                return;
            }

            if (aggr.macs && aggr.macs.length !== 0) {
                vals[aggr.name + '_aggr'] = aggr.macs.join(',');
            }

            if (aggr.lacp_mode) {
                vals[aggr.name + '_lacp_mode'] = aggr.lacp_mode;
            }

            if (aggr.nic_tags_provided) {
                aggr.nic_tags_provided.forEach(function (t) {
                    vals[t + '_nic'] = aggr.name;
                });
            }
        });

        return callback(null, vals);
    });
}

module.exports = {
    values: configValues,
    enabled: isEnabled,
    load: loadConfig
};
