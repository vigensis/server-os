/*
 * Copyright (c) 2015, Joyent, Inc. All rights reserved.
 *
 * IP-related utilities
 */

var net = require('net');


var MAX_IP = 4294967295;
var NIC_AUTOCONFIG = ['dhcp', 'addrconf'];


/*
 * Converts a dotted IPv4 address (eg: 1.2.3.4) to its integer value
 */
function addressToNumber(addr) {
    if (!addr || !net.isIPv4(addr)) {
        return null;
    }

    var octets = addr.split('.');
    return Number(octets[0]) * 16777216
        + Number(octets[1]) * 65536
        + Number(octets[2]) * 256
        + Number(octets[3]);
}


/*
 * Converts an integer to a dotted IP address
 */
function numberToAddress(num) {
    if (isNaN(num) || num > 4294967295 || num < 0) {
        return null;
    }

    var a = Math.floor(num / 16777216);
    var aR = num - (a * 16777216);
    var b = Math.floor(aR / 65536);
    var bR = aR - (b * 65536);
    var c = Math.floor(bR / 256);
    var d = bR - (c * 256);

    return a + '.' + b + '.' + c + '.' + d;
}


/*
 * Converts CIDR (/xx) bits to netmask
 */
function bitsToNetmask(bits) {
    var n = 0;

    for (var i = 0; i < (32 - bits); i++) {
        n |= 1 << i;
    }
    return numberToAddress(MAX_IP - n);
}


/*
 * Converts netmask to CIDR (/xx) bits
 */
function netmaskToBits(netmask) {
    var num = ~addressToNumber(netmask);
    var b = 0;
    for (b = 0; b < 32; b++) {
        if (num === 0) {
            break;
        }
        num = num >>> 1;
    }
    return 32 - b;
}

function splitCIDR(ip) {
    var parts;
    var prefix;

    parts = ip.split('/');
    if (parts.length == 2) {
        prefix = Number(parts[1]);
        return {
            'ip': parts[0],
            'prefix': prefix
        };
    }

    return {
        'ip': ip
    };
}

/**
 * Check if a specified netmask is valid (that is, is it a 32-bit number
 * with only leading 1's?)
 */
function isIPv4Netmask(netmask) {
    var inverse;

    if (!net.isIPv4(netmask)) {
        return false;
    }

    // Take the inverse of the number, so that we should only have
    // trailing 1's.
    inverse = ~addressToNumber(netmask);

    // Add 1, so that there should only be a single bit set.
    var single_bit = inverse + 1;

    // Since there should only be a single bit set, AND'ing it with
    // the string of trailing zeroes should be 0.
    var valid = (single_bit & inverse) === 0;
    return valid;
}

/**
 * Check if an address is valid for an IPv4 configuration.
 */
function isIPv4Input(ip) {
    return (ip === 'dhcp') || net.isIPv4(ip);
}

/**
 * Check if an address is valid for an IPv6 configuration.
 */
function isIPv6Input(ip) {
    return (ip === 'addrconf') || net.isIPv6(ip);
}

/**
 * Check if an address is a valid IP input
 */
function isIPInput(ip) {
    return isIPv4Input(ip) || isIPv6Input(ip);
}

/**
 * Check the input value to make sure that it's a valid IPv4 address w/
 * a routing prefix.
 */
function isCIDRv4(cidr) {
    var ip;
    var parts;
    var plen;

    parts = cidr.split('/');
    if (parts.length === 2) {
        ip = parts[0];
        plen = parseInt(parts[1], 10);
        return net.isIPv4(ip) && plen >= 8 && plen <= 32;
    }
    return false;
}

/**
 * Check the input value to make sure that it's a valid IPv6 address w/
 * a routing prefix.
 */
function isCIDRv6(cidr) {
    var ip;
    var parts;
    var plen;

    parts = cidr.split('/');
    if (parts.length === 2) {
        ip = parts[0];
        plen = parseInt(parts[1], 10);
        return net.isIPv6(ip) && plen >= 0 && plen <= 128;
    }
    return false;
}

/**
 * Check the input value to make sure that it's a valid IP address w/
 * a routing prefix.
 */
function isCIDR(cidr) {
    var parts, ip, plen;
    parts = cidr.split('/');
    if (parts.length === 2) {
        ip = parts[0];
        plen = parseInt(parts[1], 10);
        if (net.isIPv4(ip)) {
            return plen >= 8 && plen <= 32;
        } else if (net.isIPv6(ip)) {
            return plen >= 0 && plen <= 128;
        }
    }
    return false;
}

function isCIDRv4Input(cidr) {
    return (cidr === 'dhcp') || isCIDRv4(cidr);
}

function isCIDRv6Input(cidr) {
    return (cidr === 'addrconf') || isCIDRv6(cidr);
}

/**
 * Check if the input value is either an autoconfiguration option or a valid
 * IP address with a routing prefix.
 */
function isCIDRInput(cidr) {
    return (cidr === 'dhcp') || (cidr === 'addrconf') || isCIDR(cidr);
}

var reprIPFunctions = {
    'cidrv4': isCIDRv4Input,
    'ipv4': isIPv4Input,
    'ipv4-strict': net.isIPv4,
    'cidrv6': isCIDRv6Input,
    'ipv6': isIPv6Input,
    'ipv6-strict': net.isIPv6
};

/**
 * This function is responsible for getting the representative IP address
 * from a list of IPs. It allows filtering by address family, if needed.
 *
 * In the event that there are no IP addresses in the list that meet the
 * criteria, the function will return undefined.
 *
 * Note that this function uses isIPv{4,6}Input, so it considers the text
 * 'dhcp' an IPv4 address, and the text 'addrconf' an IPv6 address.
 * If the address needs to be an exact IPv4 or IPv6 address, ipv4-strict
 * and ipv6-strict can be used instead.
 */
function getRepresentativeIP(ips, inet) {
    var i;
    var ip;
    var validate;

    if (!Array.isArray(ips)) {
        throw new Error('expected an array of IP addresses: ' + ips);
    }

    if (reprIPFunctions.hasOwnProperty(inet)) {
        validate = reprIPFunctions[inet];
    } else {
        throw new Error('Unrecognized method for getting a representative '
            + 'IP address: ' + inet);
    }

    for (i = 0; i < ips.length; i++) {
        ip = ips[i];
        if (validate(ip)) {
            return ip;
        }
    }

    return undefined;
}

function isAutoConfigOption(opt) {
    return NIC_AUTOCONFIG.indexOf(opt) !== -1;
}

module.exports = {
    isAutoConfigOption: isAutoConfigOption,
    isIPv4Netmask: isIPv4Netmask,
    isIPv4Input: isIPv4Input,
    isIPv6Input: isIPv6Input,
    isIPInput: isIPInput,
    isCIDRv4: isCIDRv4,
    isCIDRv6: isCIDRv6,
    isCIDR: isCIDR,
    splitCIDR: splitCIDR,
    isCIDRInput: isCIDRInput,
    getRepresentativeIP: getRepresentativeIP,
    addressToNumber: addressToNumber,
    aton: addressToNumber,
    bitsToNetmask: bitsToNetmask,
    netmaskToBits: netmaskToBits,
    numberToAddress: numberToAddress,
    ntoa: numberToAddress
};
