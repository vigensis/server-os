/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License, Version 1.0 only
 * (the "License").  You may not use this file except in compliance
 * with the License.
 *
 * You can obtain a copy of the license at http://smartos.org/CDDL
 *
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file.
 *
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 *
 * Copyright (c) 2018, Joyent, Inc.
 *
 * This module exists to watch files for changes. It is somewhat similar to
 * node's fs.watch except:
 *
 *  * FsWatcher.watch() is asynchronous and optionally can call a callback when
 *    it actually starts watching.
 *  * FsWatcher works with files that do not exist yet, notifying you when they
 *    are created.
 *
 * To use you should do something like:
 *
 *  var fsw = new FsWatcher({log: log});
 *  fsw.once('ready', function ready() {
 *      fsw.watch('/path/to/some/file', function (err) { ... });
 *      fsw.unwatch('/path/to/some/file', function (err) { ... });
 *      fsw.status(function (err, obj) { ... });
 *      fsw.stop();
 *  });
 *  fsw.on(<event type>, callback(event));
 *  fsw.start();
 *
 * Where the event types can be:
 *
 *  * event - for any event
 *  * create - emitted when a file is created
 *  * change - emitted when a file is modified
 *  * delete - emitted when a file is deleted
 *
 * How this works:
 *
 *   This module is a wrapper around the fswatcher tool. That tool is driven by
 *   commands on STDIN which start and stop watches on files. Output goes to
 *   STDOUT (as json)  and is scraped by this module and turned into events.
 *
 * When `fsw.start()` is called, the companion fswatcher C program is started,
 * and a 'ready' event is emitted when the program is fully loaded and ready to
 * start receiving input.  Once it is ready, you may call .watch, .unwatch,
 * etc.
 *
 * When a file watch is attempted, the command to watch it is sent to the
 * fswatcher C program.  If it succeeds, the callback is fired immediately
 * and any new events for the file will be emitted when they are seen.  If
 * it fails however, a successful callback is still fired, but the file
 * is moved to a retry "interval".  The term interval is used here, but it's
 * actually a JavaScript setTimeout under the hood that calls itself as part
 * of the retry logic.
 *
 * The common case is, when a .watch() command is given, the file we want to
 * watch either exists or will exist very soon.  Because of this, if the initial
 * watch fails, that file specifically will be retried (the WATCH command sent
 * to the fswatcher program again) 10 times every 200ms - this is called the
 * INITIAL_WATCH_INTERVAL.  If it succeeds during this time, the timeout will
 * be cleared and a 'create' event for the file will be emitted.
 *
 * If the file fails the INITIAL_WATCH_INTERVAL, it will move over to the
 * LONG_WATCH_INTERVAL.  This is an interval (again, actually a setTimeout
 * that calls itself when finished) that runs every 10 seconds to retry every
 * file that does not yet exist.  This is a single interval that runs every
 * 10 seconds no matter what, and loops every file that we want to watch but
 * does not yet exist.  When a WATCH command succeeds for a file in this
 * interval it is removed from the "not_yet_watching" list and a 'create'
 * event for the file be emitted.
 *
 */

var cp = require('child_process');
var EventEmitter = require('events').EventEmitter;
var util = require('util');

var assert = require('/usr/node/node_modules/assert-plus');
var bunyan = require('/usr/node/node_modules/bunyan');
var hrtime = require('/usr/vm/node_modules/hrtime');
var jsprim = require('/usr/vm/node_modules/jsprim');
var LineStream = require('/usr/node/node_modules/linestream');
var RingBuffer = require('/usr/vm/node_modules/bunyan').RingBuffer;
var vasync = require('/usr/vm/node_modules/vasync');

/*
 * when a file is watched but does not yet exist, FsWatcher will default to
 * retry watching the file INITIAL_WATCH_TRIES (10) tries every
 * INITIAL_WATCH_DELAY (200) milliseconds before transitioning the file to the
 * long watch interval.
 */
var INITIAL_WATCH_DELAY = 200;
var INITIAL_WATCH_TRIES = 10;

/*
 * when a file fails to be watched during its own initial watch interval it
 * will be transferred to a longer class-wide interval that tries to watch all
 * unwatched files every LONG_WATCH_DELAY (10000) milliseconds.
 */
var LONG_WATCH_DELAY = 10 * 1000;

// fswatcher.c can handle 2^64, but to be safe with JavaScript we restrict the
// maximum key.
var FSWATCHER_MAX_KEY = Math.pow(2, 32);

// illegal characters for filenames - this limitation is in fswatcher.c
var ILLEGAL_FILENAME_CHARS = ['\n', '\0'];

// number of fswatcher stderr lines to hold in memory
var FSWATCHER_STDERR_LINES = 100;

// number of messages to store to calculate delay
var MESSAGE_DELAY_BUFFER_SIZE = 1000;

// minimum allowable time in ms before a warning log is emitted
var MESSAGE_DELAY_LOG_THRESHOLD = 10;

// companion C program that is our interface to event ports
var FSWATCHER_CMD = '/usr/vm/sbin/fswatcher';
if (process.env.FSWATCHER_CMD) {
    FSWATCHER_CMD = process.env.FSWATCHER_CMD;
}

// default logger if left unspecified
var LOG = bunyan.createLogger({
    level: 'debug',
    name: 'fswatcher',
    streams: [
    {
        stream: process.stderr,
        level: 'debug'
    }
    ],
    serializers: bunyan.stdSerializers
});

function noop() {}

/*
 * Create an FsWatcher instance
 */
function FsWatcher(opts) {
    var self = this;

    EventEmitter.call(self);

    opts = opts || {};
    self.log = opts.log || LOG;

    assert.object(opts, 'opts');
    assert.object(self.log, 'opts.log');
    assert.optionalBool(opts.dedup, 'opts.dedup');
    assert.optionalNumber(opts.initial_watch_delay,
        'opts.initial_watch_delay');
    assert.optionalNumber(opts.initial_watch_tries,
        'opts.initial_watch_tries');
    assert.optionalNumber(opts.long_watch_delay, 'opts.long_watch_delay');

    // turned on when .stop() is issue and off when the process exits
    self.stopping = false;

    // if we should dedup events from the same time (millisecond resolution)
    self.dedup = opts.dedup;

    // files currently being watched
    self.watching = {};

    // files that need to be watched but don't exist yet
    self.not_yet_watching = {};

    // fswatcher stderr lines generated
    self.stderr_buffer = new RingBuffer({limit: FSWATCHER_STDERR_LINES});

    // time delta from when messages are generated by fswatcher.c, to when they
    // are processed by this module.
    self.message_delay_buffer = new RingBuffer({
        limit: MESSAGE_DELAY_BUFFER_SIZE
    });

    // see comments at the top of this file for "default values" for information
    // on these variables
    self.initial_watch_delay = opts.initial_watch_delay || INITIAL_WATCH_DELAY;
    self.initial_watch_tries = opts.initial_watch_tries || INITIAL_WATCH_TRIES;
    self.long_watch_delay = opts.long_watch_delay || LONG_WATCH_DELAY;
}
util.inherits(FsWatcher, EventEmitter);

/*
 * start the long interval
 */
FsWatcher.prototype.start = function start() {
    var self = this;

    assert(!self.isRunning(), 'already running');

    self.cur_request_key = 0;
    self.pending_actions = {};

    /*
     * We store the previous event seen to use for deduplication purposes -
     * if the same exact event is seen within the same millisecond every event
     * after the first is thrown out.
     */
    self.prev_event = null;

    // no matter what, this loop runs to watch any unwatched files
    function long_watch_interval() {
        self._watchUnwatchedFiles(function _watchUnwatchedFilesDone() {
            self.long_watch_timeout = setTimeout(long_watch_interval,
                self.long_watch_delay);
        });
    }
    self.long_watch_timeout = setTimeout(long_watch_interval,
        self.long_watch_delay);

    // start the companion C program
    self.watcher = cp.spawn(FSWATCHER_CMD, ['-r', '-j'], {stdio: 'pipe'});
    self.watcher_pid = self.watcher.pid;

    /*
     * stdout is newline separated JSON.  It is broken into lines here and each
     * raw line (String) is pushed on the vasync res_queue that handles parsing
     * and processing it.  A queue is used to add a callback to processing a
     * single line of stdout - this way, any async work required by a stdout
     * line is handled before the line is processed.
     */
    var stdoutls = new LineStream();
    self.watcher.stdout.pipe(stdoutls).on('readable', function stdoutReady() {
        var line;
        while ((line = stdoutls.read()) !== null) {
            self.log.trace({line: line}, 'fswatcher stdout line');
            self.res_queue.push(line);
        }
    });

    /*
     * stderr can contain useful debugging information from the fswatcher
     * program, so all lines are output via log.trace(), and the last
     * FSWATCHER_STDERR_LINES lines are stored in a ring buffer and printed if
     * a fatal error occurs
     */
    var stderrls = new LineStream();
    self.watcher.stderr.pipe(stderrls).on('readable', function stderrReady() {
        var line;
        while ((line = stderrls.read()) !== null) {
            self.log.trace({line: line}, 'fswatcher stderr line');
            self.stderr_buffer.write(line);
        }
    });

    /*
     * handle watcher exiting.  if this is not the result of .stop(), we error
     * loudly
     */
    self.watcher.on('close', function fswatcherClosed(code, signal) {
        var e = new Error('fswatcher exited');
        e.code = code;
        e.signal = signal;
        e.pid = self.watcher_pid;
        e.stderr = self.stderr_buffer.records.join('\n');

        self.stderr_buffer.records = [];
        self.watcher = null;
        self.watcher_pid = null;

        if (self.stopping) {
            self.log.debug({err: e, signal: signal, code: code, pid: e.pid},
                'fswatcher exited');
            assert.func(self.stop_cb, 'stop() not called');
            self.stop_cb();
            delete self.stop_cb;
            self.stopping = false;
        } else {
            assert(!self.stop_cb, 'stop cb set without .stop() being called');
            self.log.error({err: e, signal: signal, code: code, pid: e.pid},
                'fswatcher exited');
            self.log.error({dump: self.dump()},
                'fswatcher .dump()');
            self.log.error({stderr: e.stderr}, 'fswatcher stderr');
            self.emit('error', e);
        }
    });

    /*
     * allow the consumer of this module to watch for errors with the child
     * process
     */
    self.watcher.on('error', function fswatchError(err) {
        self.log.error({err: err}, 'fswatcher error');
        self.emit('error', err);
    });

    /*
     * this queue handles line-by-line stdout responses from the fswatcher.c
     * program
     */
    self.res_queue = vasync.queue(function stdoutQueue(line, cb) {
        var err;
        var delta;
        var ms1;
        var ms2;
        var obj;

        if (!self.isRunning()) {
            self.log.warn({line: line},
                'stdout received while not running');
            cb();
            return;
        }

        try {
            obj = JSON.parse(line);
            assert.string(obj.type, 'stdout obj.type');
            hrtime.assertHrtime(obj.time, 'stdout obj.time');
        } catch (parseErr) {
            self.log.error({
                err: parseErr,
                line: line
            }, 'BAD JSON');
            throw parseErr;
        }
        self.log.trace({obj: obj}, 'fswatcher event');

        if (self.dedup && self.prev_event !== null) {
            // convert both monotonic timers to milliseconds for dedup purposes
            ms1 = jsprim.hrtimeMillisec(obj.time);
            ms2 = jsprim.hrtimeMillisec(self.prev_event.time);

            if (self.prev_event.pathname === obj.pathname
                && self.prev_event.type === obj.type
                && ms1 === ms2) {

                self.log.debug({obj: obj}, 'discarding duplicate object');
                process.nextTick(cb);
                return;
            }
        }
        self.prev_event = jsprim.deepCopy(obj);

        delta = jsprim.hrtimeMillisec(process.hrtime(obj.time));
        self.message_delay_buffer.write(delta);
        if (delta > MESSAGE_DELAY_LOG_THRESHOLD) {
            self.log.warn({deltaMs: delta, avg: self.messageDelays()},
                'message took %dms to process (> %dms)',
                delta, MESSAGE_DELAY_LOG_THRESHOLD);
        }

        switch (obj.type) {
        case 'ready':
            handleReady(obj, cb);
            break;
        case 'event':
            handleEvent(obj, cb);
            break;
        case 'response':
            handleResponse(obj, cb);
            break;
        case 'error':
        default:
            err = new Error('dispatching error');
            self.log.warn({err: err, obj: obj}, err.message);
            throw err;
        }
    }, 1);

    function handleReady(obj, cb) {
        self.emit('ready', obj);
        cb();
    }

    function handleEvent(obj, cb) {
        assert.bool(obj.final, 'obj.final');
        assert.arrayOfString(obj.changes, 'obj.changes');
        assert.string(obj.pathname, 'obj.pathname');

        var f = obj.pathname;
        var w = self.watching[f];
        assert.object(w, 'not watching ' + obj.pathname);

        // UNWATCH is queued, ignore event
        if (!w.active) {
            cb();
            return;
        }

        // fswatcher.c is done watching this file, queue a rewatch
        if (obj.final) {
            self.log.debug({f: f}, 'file was final, queueing rewatch');
            delete self.watching[f];
            self.watch(f);
        }

        if (obj.changes.indexOf('FILE_MODIFIED') !== -1)
            obj.type = 'change';
        if (obj.changes.indexOf('FILE_RENAME_TO') !== -1)
            obj.type = 'change';
        if (obj.changes.indexOf('FILE_TRUNC') !== -1)
            obj.type = 'change';
        if (obj.changes.indexOf('FILE_DELETE') !== -1)
            obj.type = 'delete';
        if (obj.changes.indexOf('UNMOUNTED') !== -1)
            obj.type = 'delete';

        if (obj.final && obj.type !== 'delete') {
            /*
             * An event marked as "final" means that fswatcher.c will not
             * attempt to rewatch the file.  It's possible that a file could
             * be marked as "final" without a "delete" event being seen,
             * because of the asynchronous nature of filesystem events.
             *
             * In this case, we log a warning, and pretend it was a delete -
             * since the file is effectively gone for our purposes.
             */
            self.log.warn({obj: obj}, 'final event seen for non-delete type');
            obj.type = 'delete';
        }

        if (obj.type !== 'event')
            self.emit(obj.type, obj);
        self.emit('event', obj);
        cb();
    }

    function handleResponse(obj, cb) {
        assert.number(obj.key, 'obj.key');
        assert.number(obj.code, 'obj.code');
        assert.string(obj.result, 'obj.result');
        assert.optionalString(obj.pathname, 'obj.pathname');
        assert.optionalString(obj.message, 'obj.message');
        assert.optionalObject(obj.data, 'obj.data');

        var pa = self.pending_actions[obj.key];

        assert.object(pa, 'pending_action ' + obj.key);
        assert.func(pa.cb, 'pending_action.cb ' + obj.key);

        var t = process.hrtime();
        var delta = hrtime.hrtimeDeltaPretty(t, pa.started);

        self.log.trace('command %s took %s', pa.cmd, delta);

        pa.cb(null, obj);
        delete self.pending_actions[obj.key];
        cb();
    }
};

/*
 * stop watching everything
 */
FsWatcher.prototype.stop = function stop(cb) {
    var self = this;

    assert(self.isRunning(), 'not running');
    assert(!self.stop_cb, 'stop() aready issued');
    assert.func(cb, 'cb');

    self.stop_cb = cb;
    self.stopping = true;

    // stop the watcher
    self.watcher.kill();

    // clear all watches that haven't been established yet
    Object.keys(self.not_yet_watching).forEach(function clearNotYetWatching(f) {
        var o = self.not_yet_watching[f];

        if (o.timeout) {
            clearTimeout(o.timeout);
            o.timeout = null;
        }

        delete self.not_yet_watching[f];
    });

    // clear all existing watches
    self.watching = {};

    // stop the long_watch_interval
    clearTimeout(self.long_watch_timeout);
    self.long_watch_timeout = null;
};

/*
 * watch a file
 */
FsWatcher.prototype.watch = function watch(f, cb) {
    var self = this;
    cb = cb || noop;

    var initial = true;

    assert(self.isRunning(), 'not running');
    assert.string(f, 'filename unspecified');
    assert.func(cb, 'cb');

    // validate filename
    var e = self._validFilename(f);
    if (e) {
        cb(e);
        return;
    }

    /*
     * callback with an error if we've already been instructed to watch this
     * file
     */
    if (self._isWatching(f)) {
        cb(new Error('already watchng ' + f));
        return;
    }

    /*
     * all new files start off in the 'not_yet_watching' bucket and are moved
     * to the 'watching' bucket when/if a call to `fs.watch(f)` is successful
     */
    self.not_yet_watching[f] = {
        tries: 0,
        timeout: null,
        long_watch: false
    };

    /*
     * try to watch the file - this function will call itself multiple times
     * based on the values set in the constructor if it fails before moving the
     * file to the long interval
     */
    tryWatching();

    function tryWatching() {
        var o = self.not_yet_watching[f];

        /*
         * watch was cancelled (probably shutting down or told to unwatch),
         * just give up
         */
        if (o === undefined) {
            if (initial) {
                initial = false;
                cb();
            }
            return;
        }

        o.timeout = null;

        /*
         * we've tried too many times, just give up and let the long interval
         * catch it
         */
        if (o.tries >= self.initial_watch_tries) {
            self.log.trace('%s exceeded max tries, moving to long interval', f);
            o.long_watch = true;
            if (initial) {
                initial = false;
                cb();
            }
            return;
        }

        self._tryWatching(f, function _tryWatching_done(err) {
            if (err) {
                o.tries++;
                o.timeout = setTimeout(tryWatching, self.initial_watch_delay);
                self.log.trace('%d/%d %s watch failed',
                    o.tries, self.initial_watch_tries, f);
                if (initial) {
                    initial = false;
                    cb();
                }
                return;
            }

            // watch succeeded!
            self.watching[f] = {
                active: true
            };
            delete self.not_yet_watching[f];

            var obj = {
                type: 'create',
                time: process.hrtime(),
                pathname: f
            };

            if (!initial) {
                self.emit('create', obj);
                self.emit('event', obj);
            }

            self.log.trace('%d/%d %s watch succeeded',
                o.tries, self.initial_watch_tries, f);

            if (initial) {
                initial = false;
                cb();
            }
        });
    }
};

/*
 * stop watching a file
 */
FsWatcher.prototype.unwatch = function unwatch(f, cb) {
    var self = this;
    cb = cb || noop;

    assert(self.isRunning(), 'not running');
    assert.string(f, 'filename unspecified');
    assert.func(cb, 'cb');

    // validate filename
    var e = self._validFilename(f);
    if (e) {
        cb(e);
        return;
    }

    if (self.watching[f]) {
        if (self.watching[f].active) {
            self.watching[f].active = false;
            var cmd = util.format('UNWATCH %s', f);
            self._sendCommand(cmd, function _sendCommandDone(err, obj) {
                if (err) {
                    cb(err);
                    return;
                }

                delete self.watching[f];
                cb();
            });
        } else {
            delete self.watching[f];
            cb();
        }
    } else if (self.not_yet_watching[f]) {
        if (self.not_yet_watching[f].timeout) {
            clearTimeout(self.not_yet_watching[f].timeout);
            self.not_yet_watching[f].timeout = null;
        }
        delete self.not_yet_watching[f];
        cb();
    } else {
        throw new Error('not watching ' + f);
    }
};

/*
 * Get child process status
 */
FsWatcher.prototype.status = function status(cb) {
    var self = this;

    assert(self.isRunning(), 'not running');
    assert.func(cb, 'cb');

    self._sendCommand('STATUS', cb);
};

/*
 * send stdin to the watcher program and callback when stdout
 * is receieved.  the `cmd` arg should look something like this:
 *
 *   'WATCH /path/to/file|12345'
 *   'UNWATCH /other/path'
 *
 * A key will be prepended to track the request as well as a trailing newline
 * character.
 */
FsWatcher.prototype._sendCommand = function _sendCommand(cmd, cb) {
    var self = this;

    var key;

    assert(self.isRunning(), 'not running');
    assert.string(cmd, 'cmd');
    assert.func(cb, 'cb');

    // ensure no newline is present
    assert(cmd.indexOf('\n') === -1, util.format('invalid command: "%s"',
        cmd));

    // generate a unique key for the request, this will let us know
    // which response is meant for us
    key = self._nextRequestKey();

    assert(!self.pending_actions[key], 'key already used: ' + key);

    cmd = util.format('%d %s\n', key, cmd);

    // when the response for this key is received, the callback will be called
    self.pending_actions[key] = {
        started: process.hrtime(),
        cmd: cmd,
        cb: cb
    };

    // write the command to the watcher
    self.log.trace({cmd: cmd.trim()}, 'writing to fswatcher stdin');
    try {
        self.watcher.stdin.write(cmd);
    } catch (err) {
        self.log.error({err: err}, 'failed to write to stdin');
        delete self.pending_actions[key];
        cb(err);
        return;
    }
};

/*
 * generate the next index to use for a request
 */
FsWatcher.prototype._nextRequestKey = function _nextRequestKey() {
    var self = this;

    self.cur_request_key = (self.cur_request_key + 1) % FSWATCHER_MAX_KEY;

    return self.cur_request_key;
};


/*
 * check if we are, or were instructed to, watch a file
 */
FsWatcher.prototype._isWatching = function _isWatching(f) {
    var self = this;

    assert.object(self.watching, 'self.watching');
    assert.object(self.not_yet_watching, 'self.not_yet_watching');

    return jsprim.hasKey(self.watching, f)
        || jsprim.hasKey(self.not_yet_watching, f);
};

/*
 * validate a filename string
 *
 * returns null on success or an Error object on failure
 */
FsWatcher.prototype._validFilename = function _validFilename(f) {
    try {
        ILLEGAL_FILENAME_CHARS.forEach(function checkFilename(c) {
            assert.equal(f.indexOf(c), -1, 'filename contains bad char ' + c);
        });
    } catch (e) {
        return e;
    }
    return null;
};

/*
 * try to watch all unwatched files - this will be called at an interval
 * specified in the constructor options or at a default of every 10 seconds
 */
FsWatcher.prototype._watchUnwatchedFiles =
    function _watchUnwatchedFiles(cb) {

    var self = this;

    assert.object(self.not_yet_watching, 'self.not_yet_watching');

    var started_watching = 0;
    var still_waiting = 0;
    var then = process.hrtime();
    var not_yet_watching_keys = Object.keys(self.not_yet_watching);

    vasync.forEachParallel({
        inputs: not_yet_watching_keys,
        func: function watchUnwatchedFile(f, cb2) {
            var o = self.not_yet_watching[f];

            // this interval only looks for files that are in the "long_watch"
            // bucket
            if (!o || !o.long_watch) {
                cb2();
                return;
            }

            self._tryWatching(f, function _tryWatchingDone(err) {
                if (err) {
                    // watch failed, still waiting for this file to exist
                    still_waiting++;
                    cb2();
                    return;
                }

                // watch succeeded! we can now emit a 'create' event
                // and stop waiting on this file to exist
                self.watching[f] = {
                    active: true
                };
                delete self.not_yet_watching[f];
                started_watching++;

                var obj = {
                    type: 'create',
                    time: process.hrtime(),
                    pathname: f
                };

                self.emit('create', obj);
                self.emit('event', obj);

                cb2();
            });
        }
    }, function _watchUnwatchedFilesDone(err) {
        var now = process.hrtime();
        var delta = hrtime.hrtimeDelta(now, then);
        var prettyDelta = hrtime.prettyHrtime(delta);
        if (started_watching > 0 || still_waiting > 0) {
            self.log.debug('FsWatcher _watchUnwatchedFiles: '
                + 'looped files: %d, started watching: %d, '
                + 'still waiting: %d, took: %s',
                not_yet_watching_keys.length,
                started_watching,
                still_waiting,
                prettyDelta);
        }

        cb();
    });
};

/*
 * send a command to watch the filename given, and callback when the response
 * is seen.  an error is set if the file fails to watch, and no error on
 * success
 */
FsWatcher.prototype._tryWatching = function _tryWatching(f, cb) {
    var self = this;

    var cmd = util.format('WATCH %s', f);

    self._sendCommand(cmd, function _sendCommandDone(err, obj) {
        if (err) {
            cb(err);
            return;
        }

        switch (obj.result) {
        case 'SUCCESS':
            cb(null, obj);
            break;
        case 'FAIL':
            cb(new Error(obj.message), obj);
            break;
        default:
            throw new Error('unknown result: ' + obj.result);
        }
    });
};

/*
 * Returns true if the child process is currently running and a stop() has not
 * been issued
 */
FsWatcher.prototype.isRunning = function isRunning() {
    var self = this;

    return self.watcher && !self.stopping;
};

/*
 * Return the current state as an object
 */
FsWatcher.prototype.dump = function dump() {
    var self = this;

    assert.object(self.watching, 'self.watching');
    assert.object(self.not_yet_watching, 'self.not_yet_watching');

    return {
        message_delays: self.messageDelays(),
        watching: Object.keys(self.watching),
        not_yet_watching: Object.keys(self.not_yet_watching),
        pending_actions: self.pending_actions,
        watcher_pid: self.watcher_pid,
        running: self.isRunning()
    };
};

/*
 * Calculate the averages for the message delay buffer
 */
FsWatcher.prototype.messageDelays = function messageDelays() {
    var self = this;

    assert.object(self.message_delay_buffer, 'self.message_delay_buffer');

    var avg;
    var i;
    var o = {};
    var records = self.message_delay_buffer.records.slice(0).reverse();
    var sum;

    /*
     * Calculate delays using the last N messages where N is a number that
     * increments 10x every iteration.  i.e. this will process the averages for
     * the last 1, 10, 100, and 1000 messages averaged.
     */
    for (i = 1; i <= records.length; i *= 10) {
        sum = records.slice(0, i).reduce(function sumRecords(a, b) {
            return a + b;
        }, 0);
        avg = sum / i;
        o[i] = avg;
    }

    return o;
};

module.exports.FsWatcher = FsWatcher;

if (require.main === module) {
    var _f = process.argv[2];
    var fsw = new FsWatcher();
    fsw.once('ready', function _ready(obj) {
        fsw.watch(_f, function _watch() {
            console.log('watching %s', _f);
        });
    });
    fsw.on('event', function _event(ev) {
        console.log('new event: %j', ev);
    });
    fsw.start();
}
