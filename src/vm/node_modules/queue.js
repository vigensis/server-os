/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License, Version 1.0 only
 * (the "License").  You may not use this file except in compliance
 * with the License.
 *
 * You can obtain a copy of the license at http://smartos.org/CDDL
 *
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file.
 *
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 *
 * Copyright (c) 2018, Joyent, Inc.
 *
 */

/*
 * Queue is a wrapper around a vasync queue with a few added features:
 *
 * - Ability to pause, fast-forward, and resume the queue
 * - Optional deduplication for queued tasks with the same string identifier
 * - Optional timeout for tasks taking too long
 * - Tasks (functions) get a custom logger with unique task identifier
 * - Timing stats for task create (enqueue), start, and finish.
 * - 'idle' event for the queue X ms after the vasync queue has drained
 *
 * Every task pushed to the queue must contain at least a function to run, and
 * a string identifier (called description).
 *
 * Example
 *
 * var q = new Queue({
 *     log: log,     // [required] bunyan logger
 *     workers: 1,   // [required] number of concurrent workers
 *     dedup: true,  // [optional] discard enqueued tasks with same description
 *     paused: true, // [optional] start paused, defauts to false
 *     idleTime: 200 // [optional] time in ms to be considered, defaults to
 *                                 instant ('drain' is 'idle')
 *
 * });
 *
 * q.enqueue({
 *     // used for logging, and deduplication if enabled
 *     description: 'sysevent seen for zone foo',
 *
 *     // kill the task if it takes more than 30 seconds, default is no timeout
 *     timeout: 30 * 1000,
 *
 *     // the function to run - cb doesn't expect any arguments
 *     func: function myTask(extras, cb) {
 *         // this logger contains the task object, which has the tasks UUID,
 *         // description, and more.  This is a childlog of the logger passed
 *         // in during queue creation.
 *         extras.log('doing something');
 *
 *         somethingAsync(function somethingAsyncDone() {
 *             cb(); // let the queue know this task is over
 *         });
 *     }
 * });
 *
 * q.enqueue({
 *     description: 'sysevent seen for zone bar',
 *     func: function syseventFunc(extras, cb) { cb(); }
 * });
 *
 * .enqueue() also returns a value: true if the task was queued or false if it
 * was discarded by deduplication.  For example:
 *
 * ret = q.enqueue({
 *     description: 'foo',
 *     func: function fooFunc(extras, cb) { cb(); }
 * });
 * // ret => true, no task with this name is enqueued
 *
 * ret = q.enqueue({
 *     description: 'foo',
 *     func: function otherFooFunc(extras, cb) { cb(); }
 * });
 * // ret => false, a task with this name is enqueued so this task is discarded
 *
 * There are now 3 tasks on the queue but it is currently paused, we can uncork
 * it with:
 *
 * q.resume();
 *
 * Finally, Queue supports fast-forwarding the queue.  When a task is enqueued,
 * the current timestamp is stored for it (called "create" time).  When you
 * call .fastForward(), you pass in an hrtime Array, and all items
 * created on or before that time will be run through the queue, and the
 * callback will fire when all tasks are completed.
 *
 * For example (queue must be paused or an error is thrown)
 *
 * var one_minute_ago = process.hrtime();
 * one_minute_ago[0] -= 60;
 * var opts = {
 *     timeout: 60 * 1000  [optional] timeout to error out fast-forward
 * };
 * q.fastForward(one_minute_ago, opts, function fastForwarded(err) {
 *     // `err` can only be set if opts.timeout was specified and exceeded.
 *     // In this event, the tasks are still running when this callback is
 *     // fired, but the queue is still technically paused and not running
 *     // any new tasks enqueued.
 *
 *     // Otherwise, this means the enqueued tasks created exactly or more than
 *     // a minute ago are now complete.
 * });
 *
 */

var EventEmitter = require('events').EventEmitter;
var util = require('util');

var assert = require('/usr/node/node_modules/assert-plus');
var hrtime = require('/usr/vm/node_modules/hrtime');
var libuuid = require('/usr/node/node_modules/uuid');
var vasync = require('/usr/vm/node_modules/vasync');

module.exports.Queue = Queue;

/*
 * Create an event queue
 *
 * opts = {
 *     log: log,       // [required] bunyan logger
 *     workers: 1,     // [required] number of concurrent workers
 *     dedup: true,    // [optional] discard enqueued tasks with same
 *                        description
 *     paused: true,   // [optional] start paused, defauts to false
 *     idleTime: 1000, // [optional] time in ms from when the vasync queue
 *                        drains to when the 'idle' event is emitted, defaults
 *                        to 0ms (instant)
 * };
 */
function Queue(opts) {
    var self = this;

    EventEmitter.call(self);

    assert.object(opts, 'opts');
    assert.object(opts.log, 'opts.log');
    assert.number(opts.workers, 'opts.workers');
    assert.optionalBool(opts.dedup, 'opts.dedup');
    assert.optionalBool(opts.paused, 'opts.paused');
    assert.optionalNumber(opts.idleTime, 'opts.idleTime');

    // paused
    self.paused = !!opts.paused;
    self.paused_time = self.paused ? process.hrtime() : null;

    // idle timer
    self.idleTime = opts.hasOwnProperty('idleTime') ? opts.idleTime : 0;
    self.idle = !self.paused;

    assert.number(self.idleTime, 'self.idleTime');
    assert(self.idleTime >= 0, 'self.idleTime cannot be negative');

    // max workers
    self.workers = opts.workers;

    // logger
    self.log = opts.log;

    // should dedup
    self.dedup = opts.dedup;

    // tasks waiting to run (pushed when paused)
    self.paused_queue = [];

    // vasync queue
    self.queue = vasync.queue(function queueTaskProcess(task, cb) {
        assert.object(task, 'task');
        assert.func(cb, 'cb');

        task.started_at = process.hrtime();

        // "extras" is passed to the user function when it is called
        var childlog = self.log.child({task: task});
        var extras = {
            log: childlog
        };

        // If a task timeout is specified, create a timeout for the task to
        // emit an error if it takes too long to execute
        var timeout;
        if (task.timeout) {
            timeout = setTimeout(function queueTaskTimeout() {
                var err = new Error('timeout exceeded');
                childlog.fatal({err: err, timeout: task.timeout},
                    'task took longer than %dms', task.timeout);
                self.emit('error', err);
            }, task.timeout);
        }

        childlog.debug('starting task');
        task.func(extras, function queueTaskFuncDone(err) {
            task.finished_at = process.hrtime();
            var delta = hrtime.hrtimeDelta(task.finished_at, task.started_at);

            childlog.debug({delta: delta}, 'finished task in %s',
                hrtime.prettyHrtime(delta));

            // clear the timeout
            if (timeout) {
                clearTimeout(timeout);
                timeout = null;
            }

            // emit an error
            if (err) {
                childlog.error({err: err}, 'task failed: %s', err.message);
                self.emit('error', err);
            }

            cb();
        });
    }, self.workers);

    self.queue.on('drain', function queueOnDrain() {
        if (self.paused) {
            return;
        }

        self._clearIdleTimer();

        if (self.idleTime === 0) {
            self._emitIdleEvent();
            return;
        }

        self.idleTimer = setTimeout(function queueIdle() {
            self.idleTimer = null;
            self._emitIdleEvent();
        }, self.idleTime);
    });
}
util.inherits(Queue, EventEmitter);

/*
 * Push a task to the queue.  If we are currently paused the task will be
 * stored in the "paused_queue" array, to be pushed onto the vasync queue
 * at a later time as either part of a .resume() or .fastForward().  If
 * we are not paused, the task is pushed directly onto the vasync queue.
 *
 * A task must have a function set, as well as a string description.  If the
 * description of a task being pushed matches the description of a task
 * already queued to run, and opts.dedup was set in the queues constructor,
 * the task is discarded.
 *
 * Returns:
 *   true    the task was enqueued, either while paused or running
 *   false   the task wes discarded as a dup (only happens when opts.dedup)
 */
Queue.prototype.enqueue = function enqueue(opts, cb) {
    var self = this;
    var found;

    assert.object(opts, 'opts');
    assert.func(opts.func, 'opts.func');
    assert.string(opts.description, 'opts.description');
    assert.optionalNumber(opts.timeout, 'opts.timeout');
    assert.optionalFunc(cb, 'cb');

    // when a task is created, we record the time and create a unique id
    // for it
    opts.id = libuuid.create();
    opts.created_at = process.hrtime();

    // if dedup is disabled, we push the task to either the vasync queue
    // or the paused queue depending on the current state
    if (!self.dedup) {
        if (self.paused) {
            self.log.debug({opts: opts}, 'pushing to paused queue');
            self.paused_queue.push({opts: opts, cb: cb});
        } else {
            self.log.debug({opts: opts}, 'pushing to vasync queue');
            self._clearIdleTimer();
            self.queue.push(opts, cb);
        }
        return true;
    }

    // if we are here then dedup is enabled.  we check the existing queues for
    // a matching task and discard the current one if a match is found

    if (self.paused) {
        // check the paused queue first if we are paused
        found = self.paused_queue.some(function dedupPaused(o) {
            return o.opts.description === opts.description;
        });
    }

    if (!found) {
        // check the vasync queue if 1. we are not paused or, 2. the paused
        // queue didn't have a matching task
        found = self.queue.queued.some(function dedupQueued(o) {
            return o.task.description === opts.description;
        });
    }

    // a matching task was found in either queue - discard this one
    if (found) {
        self.log.debug({opts: opts}, 'duplicate task found - discarding');
        return false;
    }

    // no matching task was found - push it to the appropriate queue
    if (self.paused) {
        self.log.debug({opts: opts},
            'no duplicate task found - pushing to paused queue');
        self.paused_queue.push({opts: opts, cb: cb});
    } else {
        self.log.debug({opts: opts},
            'no duplicate task found - pushing to vasync queue');
        self._clearIdleTimer();
        self.queue.push(opts, cb);
    }

    return true;
};

/*
 * Pause the queue
 *
 * This will pause processing any newly enqueued tasks and wait for all
 * currently running and enqueued tasks to finish.
 *
 * An optional timeout may be specified to callback with an
 * error if it takes too long to stop the queue.
 */
Queue.prototype.pause = function pause(opts, cb) {
    var self = this;

    if (typeof (opts) === 'function') {
        cb = opts;
        opts = {};
    }

    assert(!self.paused, 'queue is already paused!');
    assert.object(opts, 'opts');
    assert.optionalNumber(opts.timeout, 'opts.timeout');
    assert.func(cb, 'cb');

    self.paused = true;
    self.paused_time = process.hrtime();

    // pausing the queue disables the 'idle' event from being emitted
    self._clearIdleTimer();

    // short-circuit logic if no task is currently running
    if (self.queue.npending === 0) {
        self.log.debug('queue paused');
        cb();
        return;
    }

    // task(s) running - wait for finish
    var timeout;
    if (opts.timeout) {
        timeout = setTimeout(function pauseTimeout() {
            var err = new Error('pause timeout exceeded');
            self.log.fatal({err: err, timeout: opts.timeout},
                'pause took longer than %dms', opts.timeout);
            self.queue.removeListener('drain', ondrain);
            self.resume();
            cb(err);
        }, opts.timeout);
    }

    self.queue.once('drain', ondrain);

    // vasync queue has drained, we can pause
    function ondrain() {
        if (timeout) {
            clearTimeout(timeout);
            timeout = null;
        }
        cb();
    }
};

/*
 * Resume the queue.
 *
 * This will take all of the elements of the paused_queue and push them into
 * the vasync queue.
 */
Queue.prototype.resume = function resume() {
    var self = this;

    assert(self.paused, 'queue is not paused!');
    assert(!self.idle, 'idle set while paused');
    assert(!self.idleTimer, 'idleTimer set while paused');

    self.paused = false;
    self.paused_time = null;
    self.log.debug('queue resumed - enqueueing %d tasks',
        self.paused_queue.length);

    if (self.paused_queue.length === 0) {
        self._emitIdleEvent();
        return;
    }

    self.paused_queue.forEach(function pausedForeachResume(o) {
        self.queue.push(o.opts, o.cb);
    });
    self.paused_queue = [];
};

/*
 * Fast Forward the queue to a given date.
 *
 * The queue must be paused for this to work.  Given an hrtime
 * (process.hrtime()) as the first argument, this function will process every
 * item in the queue that was queued before the time given and call the
 * callback given when it has finished (or if it has timedout).
 *
 * opts.timeout   a max time (in ms) to wait for the queue to fast-forward,
 *                this may be omitted to not create a timeout
 *
 */
Queue.prototype.fastForward = function fastForward(time, opts, cb) {
    var self = this;

    if (typeof (opts) === 'function') {
        cb = opts;
        opts = {};
    }

    assert(self.paused, 'queue must be paused to fast-forward');
    hrtime.assertHrtime(time, 'time');
    assert.object(opts, 'opts');
    assert.optionalNumber(opts.timeout, 'opts.timeout');
    assert.func(cb, 'cb');

    // loop all queued tasks and dispatch them if they were created before or
    // at fast-forward time given
    var task;
    var i = 0;
    while ((task = self.paused_queue.shift())) {
        if (hrtime.hrtimeComparator(task.opts.created_at, time) <= 0) {
            i++;
            self.queue.push(task.opts, task.cb);
        } else {
            self.paused_queue.unshift(task);
            break;
        }
    }
    self.log.debug('fast-forward pushed %d tasks into queue', i);

    // just callback immediately if no tasks were pushed
    if (i === 0) {
        cb();
        return;
    }

    // task(s) running - wait for finish
    var timeout;
    if (opts.timeout) {
        timeout = setTimeout(function fastForwardTimeout() {
            var err = new Error('fast-forward timeout exceeded');
            self.log.error({err: err, timeout: opts.timeout},
                'fast-forward took longer than %dms', opts.timeout);
            self.queue.removeListener('drain', ondrain);
            cb(err);
        }, opts.timeout);
    }

    self.queue.once('drain', ondrain);

    function ondrain() {
        if (timeout) {
            clearTimeout(timeout);
            timeout = null;
        }
        cb();
    }
};

/*
 * Clear the idleTimer if it is set
 */
Queue.prototype._clearIdleTimer = function _clearIdleTimer() {
    var self = this;

    self.idle = false;
    if (self.idleTimer) {
        self.log.debug('clearing idleTimer');
        clearTimeout(self.idleTimer);
        self.idleTimer = null;
    }
};

/*
 * Emit the idle event
 */
Queue.prototype._emitIdleEvent = function _emitIdleEvent() {
    var self = this;

    assert(!self.idle, 'idle set while _emitIdleEvent called');
    assert(!self.idleTimer, 'idleTimer set while _emitIdleEvent called');

    self.log.debug('queue is idle');
    self.idle = true;
    self.emit('idle');
};

/*
 * Return the queue status as an object.
 *
 * This is useful for stringifying and outputting as part of an HTTP request
 * for a web service, or running this and storing in memory before a process
 * crash.
 */
Queue.prototype.dump = function dump() {
    var self = this;

    var now = process.hrtime();

    var state = {
        now: hrtime.hrtimeToString(now),
        paused: self.paused,
        idle: self.idle,
        vasync_queue: {
            concurrency: self.queue.concurrency,
            npending: self.queue.npending,
            nqueued: self.queue.length(),
            pending: {},
            queued: []
        }
    };

    Object.keys(self.queue.pending).forEach(function pendingForeach(id) {
        var task = self.queue.pending[id].task;
        var o = {
            description: task.description,
            created_at: hrtime.hrtimeToString(task.created_at),
            started_at: hrtime.hrtimeToString(task.started_at),
            created_ago: hrtime.hrtimeDeltaPretty(now, task.created_at),
            started_ago: hrtime.hrtimeDeltaPretty(now, task.started_at),
            start_latency: hrtime.hrtimeDeltaPretty(task.started_at,
                task.created_at)

        };
        state.vasync_queue.pending[task.id] = o;
    });

    self.queue.queued.forEach(function queuedForeach(q) {
        var task = q.task;
        var o = {
            description: task.description,
            created_at: hrtime.hrtimeToString(task.created_at),
            created_ago: hrtime.hrtimeDeltaPretty(now, task.created_at)
        };
        state.vasync_queue.queued.push(o);
    });

    if (self.paused) {
        state.paused_at = hrtime.hrtimeToString(self.paused_time);
        state.paused_ago = hrtime.hrtimeDeltaPretty(now, self.paused_time);
        state.paused_nqueued = self.paused_queue.length;
        state.paused_queue = [];
        self.paused_queue.forEach(function pausedQueueForeach(task) {
            assert.object(task, 'task');
            assert.object(task.opts, 'task.opts');
            var o = {
                id: task.opts.id,
                description: task.opts.description,
                created_at: hrtime.hrtimeToString(task.opts.created_at),
                created_ago: hrtime.hrtimeDeltaPretty(now, task.opts.created_at)
            };
            state.paused_queue.push(o);
        });
    }

    return state;
};
