/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License, Version 1.0 only
 * (the "License").  You may not use this file except in compliance
 * with the License.
 *
 * You can obtain a copy of the license at http://smartos.org/CDDL
 *
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file.
 *
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 *
 * Copyright (c) 2018, Joyent, Inc.
 *
 */

// Ensure we're using the platform's node
// XXX TODO update this when it's been moved.
// require('/usr/node/node_modules/platform_node_version').assert();

var assert = require('assert');
var cp = require('child_process');
var spawn = cp.spawn;
var utils = require('utils');

// utils
var isUUID = utils.isUUID;
var rtrim = utils.rtrim;

/*
 * getZoneRecords() takes a uuid|zonename|null as the first option and
 * attempts to gather information from zoneadm for zones on the system using:
 *
 * if "uuid" parameter is a UUID:
 *
 *  zoneadm -z <uuid> -u <uuid> list -p
 *
 * if "uuid" parameter is not a UUID and not null:
 *
 *  zoneadm -z <uuid> list -p
 *
 * if "uuid" is null or undefined:
 *
 *  zoneadm list -p -c
 *
 * the result is an object with a member for each VM found in the output of
 * zoneadm. These member objects look like:
 *
 * {
 *    zoneid: integer (if it's running, else: null)
 *    zonename: string
 *    state: string
 *    zonepath: string (path)
 *    uuid: string (UUID)
 *    brand: string
 *    ip_type: string ("exclusive"|"shared"),
 *    zonedid: integer
 * }
 *
 * the passed in callback function will be called with:
 *
 *  callback(err, results)
 *
 * with err being set (will be an Error object) only on error and results being
 * an object keyed by uuid of the data found for the system's zones.
 *
 */
function getZoneRecords(uuid, options, callback)
{
    var args = [];
    var buffer = '';
    var cmd = '/usr/sbin/zoneadm';
    var line_count = 0;
    var lines;
    var log;
    var results = {};
    var zoneadm;
    var zoneadm_stderr = '';

    assert(options.log, 'no logger passed to getZoneRecords()');
    log = options.log;

    function _processZoneadmData(data) {
        var fields;
        var line;
        var obj;
        var zonedid;
        var zoneid;

        buffer += data.toString();
        lines = buffer.split('\n');
        while (lines.length > 1) {
            line = lines.shift();
            line_count++;
            fields = rtrim(line).split(':');
            if (fields.length === 8) {
                zonedid = Number(fields[7]);
                zoneid = Number(fields[0]);
                obj = {
                    'zoneid': isNaN(zoneid) ? null : zoneid,
                    'zonename': fields[1],
                    'state': fields[2],
                    'zonepath': fields[3],
                    'uuid': fields[4],
                    'brand': fields[5],
                    'ip_type': fields[6],
                    'zonedid': isNaN(zonedid) ? null : zonedid
                };
                log.trace({object: obj}, 'loaded zoneadm object');
                /*
                 * It's possible to end up with a zoneadm line with no uuid in
                 * some cases. If that happens, we'll check the zonename. If the
                 * zonename is a UUID, we'll use that as uuid as well. If not
                 * we'll log an error, except the global zone which we just
                 * ignore.
                 *
                 */
                if (obj.uuid && obj.uuid.length === 36) {
                    results[obj.uuid] = obj;
                } else if (isUUID(obj.zonename)) {
                    results[obj.zonename] = obj;
                    results[obj.zonename].uuid = obj.zonename;
                } else if (obj.zonename !== 'global') {
                    log.error({object: obj}, 'zoneadm object is missing uuid');
                }
            } else if (line.replace(/ /g, '').length > 0) {
                log.debug('getZoneRecords(' + uuid + ') ignoring: ' + line);
            }
        }
        buffer = lines.pop();
    }

    function _finishZoneadm(code) {
        var errmsg;
        var new_err;

        if (code === 0) {
            callback(null, results);
        } else {
            errmsg = rtrim(zoneadm_stderr);
            new_err = new Error(errmsg);
            if (errmsg.match(/No such zone configured$/)) {
                // not existing isn't always a problem (eg. existence check) so
                // we set code to ENOENT so caller can decide.
                new_err.code = 'ENOENT';
            } else {
                log.error({err: new_err, stderr: zoneadm_stderr},
                    'getZoneRecords() zoneadm[' + zoneadm.pid + '] "'
                    + args.join(',') + '" failed');
            }
            callback(new_err);
            return;
        }
    }

    // Shortcut case for tests, allows us to mock out actual call to zoneadm
    if (options.zoneadm_stdout) {
        log.trace('zoneadm_stdout passed in as option, not spawning zoneadm');

        _processZoneadmData(options.zoneadm_stdout);
        zoneadm = {pid: 'debug'};
        if (options.zoneadm_stderr) {
            zoneadm_stderr = options.zoneadm_stderr;
        }
        _finishZoneadm(options.zoneadm_code ? options.zoneadm_code : 0);

        return; // don't actually spawn
    }

    if (uuid) {
        // this gives us zone info if uuid is *either* a zonename or uuid
        if (isUUID(uuid)) {
            args.push('-z', uuid, '-u', uuid);
        } else {
            args.push('-z', uuid);
        }
    }
    args.push('list', '-p');
    if (!uuid) {
        args.push('-c');
    }

    log.debug({cmdline: cmd + ' ' + args.join(' ')}, 'executing zoneadm');
    zoneadm = spawn(cmd, args, {stdio: 'pipe'});
    log.debug('zoneadm[' + zoneadm.pid + '] running');

    // doesn't take input so close stdin now.
    zoneadm.stdin.end();

    zoneadm.on('close', function (code) {
        log.debug('zoneadm[' + zoneadm.pid + '] exited with code: ' + code
            + ' (' + line_count + ' lines to stdout)');
        _finishZoneadm(code);
    });

    zoneadm.stderr.on('data', function (data) {
        zoneadm_stderr += data.toString();
    });

    zoneadm.stdout.on('data', function (data) {
        _processZoneadmData(data.toString());
    });
}

module.exports = {
    getZoneRecords: getZoneRecords
};
